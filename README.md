# Домашнее задание к занятию 4 «Оркестрация группой Docker контейнеров на примере Docker Compose» - Хрипун Алексей

### Задание 1

https://hub.docker.com/repository/docker/kumpelalex111/custom-nginx/general


### Задание 2

Запускаем контейнер в соответствии с требованиями:
![start](img/2_1.png)

Переименовываем контейнер:
![rename](img/2_2.png)

Вводим требуемые команды:
![commands](img/2_3.png)

Поверяем, что страница доступна:
![curl](img/2_4.png)

### Задание 3

Подключаемся к стандартному вводу-вывода контейнера командой **docker attach**. С помощью этой команды подключаемся к его основному процессу. Если после подключения нажать **Ctrl+C** (т.е. послать сигнал завершения процесса), то основной процесс контейнера остановится, а вместе с ним остановится и сам контейнер:
![attach](img/3_1.png)

Запускаем снова контейнер, подключаемся и в файле конфигурации меняем порт, который слушает nginx с 80 на 81 и перезапускаем nginx командой **nginx -s reload**. Теперь страница недоступна по порту 80, но доступна по порту 81:
![nginx](img/3_2.png)

Выйдя из контейнера проверяем доступность страницы на порту 80:
![nginx1](img/3_3.png)

Страница недоступна. Это связано с тем, что в контейнер пробрасывается порт 80 (указано при запусе контейнера), но приложение внутри контейнера уже слушает порт 81.

Можно исправить ситуацию, не удаляя контейнер. Но придется его остановить (как и сам процесс Docker, что повлечет за собой остановку всех запущенных на хосте контейнеров). В каталоге /var/lib/docker/containers/<ID>/ нужно отредактировать два файла - hostconfig.json (файл конфигурации хоста) и config.v2.json.
В файле hostconfig.json, помимо прочего, находится mapping всех портов контейнера. Здесь нужно найти параметр **PortBindings** и нужно исправить порт 80 на 81:
![binding](img/4_41.png)

Также нужно в файле config.v2.json в параметре **Config** найти ключ **ExposedPorts** и указать, что теперь контейнер слушает порт 81.
Проверяем:
![check](img/3_4.png)

Удаляем запущенный контейнер без его установки командой:
```
docker rm -f custom-nginx-t2
```

### Задание 4

Запускаем два контейнера с образом Centos и Debian с проброшенным к ним внутрь в папку /data текущим каталогом хоста:
![start](img/4_1.png)

В контейнере Centos в папке /data создаем текстовый файл:
![centos](img/4_2.png)

На хостовой машине добавим еще один текстовый файл. 
![centos](img/4_3.png)

Подключаемся к контейнеру debian и проверяем наличие файлов:
![debian](img/4_4.png)

### Задание 5

При запуске docker compose если не указан файл для запуска, то по умолчанию используется файл compose.yaml. Чтобы использовать несколько конфигурационных файлов, их можно поместить в секцию **include** в файле compose.yaml:
![compose](img/5_1.png)


![compose2](img/5_3.png)

Нужно переименовать образ kumpelalex111/custom-nginx:1.0.0 в localhost:5000/custom-nginx:latest:
```
docker tag kumpelalex111/custom-nginx:1.0.0 localhost:5000/custom-nginx:latest
```
Пушим этот образ в локальный registry:
```
docker push localhost:5000/custom-nginx:latest
```
Удаляем локально закешированные образы:
```
docker image remove kumpelalex111/custom-nginx:1.0.0
docker image remove localhost:5000/custom-nginx:latest
```
Проверяем, что образов нет, пулим образ из локального registry и снова проверяем:
![local](img/5_4.png)

Открываем Portainer и осле начальной настройки переходим в local окружение в web-editor и деплоим указанный compose:
![deploy](img/5_13_1.png)

Переходим к контейнеру и смотрим inspect:
![inspect1](img/5_15.png)

![inspect2](img/5_16.png)

Удалим манифест compose.yaml и продуем запустить docker-compose поект. Выдается сообщение, что найден "бесхозный" контейнер - контейнер, который не описан в docker-compose файле. Предлагается такие контейнеры удалить.
![del](img/5_17_0.png)

Удаляем:
![del1](img/5_17.png)

Проверяем:
![del2](img/5_18.png)




